
=head1 NAME

MultiSpace - A module for specifying multiple active spaces (MAS).

=head1 SYNOPSIS

Using the ORMAS approach:

    use MultiSpace;
    my @MAS = (
        [2,3,0,0,0,0,0,0], [8,10],
        [4,4,0,0,0,0,0,0], [0,2],
    );

    my $target_space = MultiSpace->new({
        symmetry => "Cs",
        MAS => \@MAS,
        type => 1}
    );

The same space using the GAS approach:

    my @MAS = (
        [2,3,0,0,0,0,0,0], [8,10],
        [4,4,0,0,0,0,0,0], [10,10],
    );

    my $target_space = MultiSpace->new({
        symmetry => "Cs",
        MAS => \@MAS,
        type => 2}
    );

If an overall orbital ordering is defined then one can simply use number of
orbitals per space instead of number of orbital per sym per space.

    my @orbital_order = ("1.1","2.1","1.2","2.2","2.3",  
        "1.3","1.4","2.4","2.5","1.5","1.6","2.6","2.7" );

The elements are of the form "sym.index_in_sym" with one-indexing for both.  

    my @MAS = (
        5, [8,10],
        8, [0,2],
    );

    my $target_space = MultiSpace->new({
        symmetry => "Cs",
        MAS => \@MAS,
        type => 1,
        ordered_orbitals => \@orbital_order}
    );

The distribution of electrons over the spaces is generated by:
    
    my $nelec = 10;
    my @dists = $target_space->distributions($nelec);

Giving:

    use Data::Dump qw(dump);
    dump(@dists);

    ([10, 0], [9, 1], [8, 2])

The number of CSF generated in each symmetry by for particular choice of active
space and spin multiplicity can be calculated by:

    my $spin = 1;
    my %ncsf = $target_space->dimension($nelec, $spin)

Giving:

    dump(\%ncsf);

    { "0" => 441, "1" => 420 }

Subspaces may also be labelled,

    my @MAS = (
        [1,0,0,0,0,0,0,0], [2,2], "frozen",
        [5,1,0,0,0,0,0,0], [8,8], "active",
    );

this is necessary when using MAS write quantum chemistry code input files (it 
is not needed for the ukrmol+ code congen). If subspace labelling is used, all 
subspaces must be labelled even if it is just with an empty string.

=head1 DESCRIPTION

There are two approaches to specifying multiple active spacesthe Occupation 
Restricted Multiple Active Space (ORMAS) approach [1], and the Generalized 
Active Space (GAS) approach [2].

In the ORMAS approach, multiple sets of orbitals are defined, and for
each set a minimum and maximum electron occupancy is specified. Various
schemes such as CAS, CISD, RAS are subsets of this approach and are easy to
set up.

The GAS approach is similar, except that you define a cumulative minimum and 
maximum occupancy.

The implementation of ORMAS has been extended here as compared to the 
original paper. There is an option to apply further constraints by passing 
an anonymous function that enforces them:
    
    my @MAS = (
        [2,3,0,0,0,0,0,0], [8,10],
        [4,4,0,0,0,0,0,0], [0,2],
    );
    my $constraints = sub {my $dist = shift; !($dist->[1] > 1);};

    my $target_space = MultiSpace->new({
        symmetry => "Cs",
        MAS => \@MAS,
        constraints => $constraints,
        type => 1}
    );

    my @dists = $target_space->distributions($nelec);
    dump(@dists);

    ([10, 0], [9, 1])

There are several routines to transform from the MAS representation above to
a representation suitable for input to congen.
    
    my @MAS = (
        [2,3,0,0,0,0,0,0], [8,10],
        [4,4,0,0,0,0,0,0], [0,2],
    );

    my $target_space = MultiSpace->new({
        symmetry => "Cs",
        MAS => \@MAS,
        type => 1}
    );

    my @wfngrps = $target_space->congen_target($nelec);

will return an array of hashes, each hash corresponds to a single wfngrp, and 
contains those namelist variables needed to specify the target space. A single
wfngrp corresponds to a single electron distribution for target and L2 CSF.
    
    my @l2_MAS = (
        [2,3,0,0,0,0,0,0], [8,10],
        [4,4,0,0,0,0,0,0], [0,3],
        [6,6,0,0,0,0,0,0], [0,1],
    );
    my @nob0 = (12,13);
    my @qntot = (2,0,0);
    my @all_qntar = ([1,0,0],[3,0,0],[1,1,0],[3,1,0]);

    my $l2_space = MultiSpace->new({
        symmetry => "Cs",
        MAS => \@l2_MAS,
        type => 1}
    );

    my @wfngrps = $target_space->congen_scattering($nelec, \@nob0, \@qntot, \@all_qntar, $l2_space);

will return the wfngrps corresponding to a single scattering symmetry.
$l2_space is optional, and allows for a different specification of the L2 space
than the default of target space + an extra electron.

=head1 CAVEATS

congen has a hardcoded maximum number of orbital sets = 10 (not 5 as stated in 
the congen docs).

=head1 REFERENCES

[1] J. Ivanic, "Direct configuration interaction and multiconfigurational 
self-consistent-field method for multiple active spaces with variable 
occupations. I. Method," J. Chem. Phys. 119, 9364 (2003);
L<https://doi.org/10.1063/1.1615954>

[2] To be added.

=cut

package MultiSpace;

use strict;
use warnings;

use Storable 'dclone';
use List::Util qw(sum0 min);

# -----------------------------------------------------------------------------
# TODO: The following global variables are replicated from ukrmollib, to avoid
#       redundancy and possible future bugs if only one set gets modified 
#       these should be extracted from both space and ukrmollib and put in a 
#       seperate module (perhaps called symmetry). I did this so MultiSpace can
#       function as a stand-alone module. At the moment these are overided by
#       their ukrmollib counterparts when MultiSpace is used there.

# Group multiplication table as in swmol3 output
# but minus 1 to have the first IR 0 as used in congen and scatci
# For smaller groups than D2h only part of this table (e.g. 4x4 for C2v or 2x2 for C2) is used
our @group_table = (
  [ 0, 1, 2, 3, 4, 5, 6, 7 ],
  [ 1, 0, 3, 2, 5, 4, 7, 6 ],
  [ 2, 3, 0, 1, 6, 7, 4, 5 ],
  [ 3, 2, 1, 0, 7, 6, 5, 4 ],
  [ 4, 5, 6, 7, 0, 1, 2, 3 ],
  [ 5, 4, 7, 6, 1, 0, 3, 2 ],
  [ 6, 7, 4, 5, 2, 3, 0, 1 ],
  [ 7, 6, 5, 4, 3, 2, 1, 0 ]
);

our %irred_repr = (
  'D2h',   [ "Ag", "B3u", "B2u", "B1g", "B1u", "B2g", "B3g", "Au" ], # incorrect in documentation of swmol3 (in output 2px orb. are in 2 = B3u and 3d1+ are in 6 = B2g)
  'C2v',   [ "A1", "B1", "B2", "A2" ],
  'C2h',   [ "Ag", "Au", "Bu", "Bg" ],
  'D2',    [ "A", "B3", "B2", "B1" ],
  'C2',    [ "A", "B" ],
  'Cs',    [ "Ap", "App" ], # p stands for prime ', there is a problem on linux machines with '
  'Ci',    [ "Ag", "Au" ],
  'C1',    [ "A" ],
);

our %spin_multiplicity = (
  'singlet', 1,
  'doublet', 2,
  'triplet', 3,
  'quartet', 4,
  'quintet', 5,
  'sextet', 6,
  'septet', 7,
  'octet', 8,
  'nonet', 9,
);

# -----------------------------------------------------------------------------
# first_index and pairwise are taken directly from List::MoreUtils they are 
# provided here to avoid the use of any non-core perl modules.

sub first_index (&@)
{
    my $f = shift;
    foreach my $i (0 .. $#_)
    {
        local *_ = \$_[$i];
        return $i if $f->();
    }
    return -1;
}

sub pairwise (&\@\@)
{
    my $op = shift;
 
    # Symbols for caller's input arrays
    use vars qw{ @A @B };
    local (*A, *B) = @_;
 
    # Localise $a, $b
    my ($caller_a, $caller_b) = do
    {
        my $pkg = caller();
        ## no critic (TestingAndDebugging::ProhibitNoStrict, ValuesAndExpressions::ProhibitCommaSeparatedStatements)
        no strict 'refs';
        \*{$pkg . '::a'}, \*{$pkg . '::b'};
    };
 
    # Loop iteration limit
    my $limit = $#A > $#B ? $#A : $#B;
 
    ## no critic (Variables::RequireInitializationForLocalVars)
    # This map expression is also the return value
    local (*$caller_a, *$caller_b);
    ## no critic (BuiltinFunctions::ProhibitComplexMappings)
    return map {
        # Assign to $a, $b as refs to caller's array elements
        (*$caller_a, *$caller_b) = \($#A < $_ ? undef : $A[$_], $#B < $_ ? undef : $B[$_]);
 
        # Perform the transformation
        $op->();
    } 0 .. $limit;
}

# -----------------------------------------------------------------------------

sub new{
    my ($class, $args) = @_;

    my ($subspaces, $N_min, $N_max, $subspace_labels) = _to_internal_rep($args);

    if (!defined($args->{ordered_orbitals})) {
        _default_orbital_ordering($args, $subspaces);
    }

    my $self = bless { symmetry => $args->{symmetry},  # Point group symmetry
                       subspaces => $subspaces,
                       subspace_labels =>  $subspace_labels,
                       N_min => $N_min,
                       N_max => $N_max,                       
                       constraints => $args->{constraints},
                       type => $args->{type},
                       ordered_orbitals => $args->{ordered_orbitals}
                    }, $class;

}

# sub _to_internal_rep
#
# Convert to the internal representation of the MAS
#
sub _to_internal_rep{
    my ($args) = @_;

    my @subspaces = ();
    my @N_min = ();
    my @N_max = ();
    my @subspace_labels = ();

    if (!defined($args->{ordered_orbitals}) && !(ref($args->{MAS}[0]) eq 'ARRAY')) {
        die "Error: If no ordered orbitals are supplied, orbitals per symmetry per subspace must be given!";
    }

    if (defined($args->{ordered_orbitals})){
        $args->{MAS} = set_orbs_per_irrep_per_subspace_automatically(
            $args->{MAS}, $args->{ordered_orbitals}
        );
    }

    if (ref($args->{MAS}[-1]) eq 'ARRAY' ){
        for( my $i = 0; $i < @{$args->{MAS}}; $i += 2 ) {
            push(@subspaces, $args->{MAS}[$i]);
            push(@N_min, $args->{MAS}[$i+1][0]);
            push(@N_max, $args->{MAS}[$i+1][1]);
        }        
    } else {  # We have subspace labels

        for( my $i = 0; $i < @{$args->{MAS}}; $i += 3 ) {
            push(@subspaces, $args->{MAS}[$i]);
            push(@N_min, $args->{MAS}[$i+1][0]);
            push(@N_max, $args->{MAS}[$i+1][1]);
            push(@subspace_labels, $args->{MAS}[$i+2]);
        }    

    }

    return (\@subspaces, \@N_min, \@N_max, \@subspace_labels)
}

sub _default_orbital_ordering {
    my ($args, $subspaces) = @_;

    my ($norbs, @ordered_orbitals);
    for( my $ispace = 0; $ispace < @{$subspaces}; $ispace += 1 ) {
        for( my $isym = 0; $isym < @{$subspaces->[$ispace]}; $isym += 1 ) {
            $norbs = $subspaces->[$ispace][$isym];
            for my $idx (0..$norbs-1){
                push(@ordered_orbitals, ($isym+1) . '.' . ($idx+1));
            }
        }
    }

    $args->{ordered_orbitals} = \@ordered_orbitals;
}

sub clone{
    my $self = shift;
    return dclone($self);
}

# sub string_mas
#
# Returns a string representaion of the MAS suitable for printing

sub string_mas{
    my $self = shift;

    my $nspace = scalar @{$self->{N_min}}; # Get the number of subsets
    my $mas_str = "";
    if ($self->{'type'} == 1){
        $mas_str .= "Method: ORMAS\n";
    } elsif ($self->{'type'} == 2){
        $mas_str .= "Method: GAS\n";
    }
    for my $i (0..$nspace-1){
        if (@{$self->{'subspace_labels'}}){
            my $label = $self->{'subspace_labels'}->[$i];
            $mas_str .= "Space $i: [".join(",", @{$self->{'subspaces'}->[$i]}).
                    "], [$self->{'N_min'}->[$i],$self->{'N_max'}->[$i]], $label"."\n";
        } else {
            $mas_str .= "Space $i: [".join(",", @{$self->{'subspaces'}->[$i]}).
                    "], [$self->{'N_min'}->[$i],$self->{'N_max'}->[$i]]\n";            
        }

    }

    return $mas_str;
}

# sub total_orbitals
#
# Determine the total orbitals per irrep used in the entire active space

sub total_orbitals{
    my ($self) = @_;

    my $n_irreps = scalar @{$irred_repr{$self->{'symmetry'}}};
    my $nspace = scalar @{$self->{N_min}}; # Get the number of subsets
    my @total = (0) x $n_irreps;

    foreach my $subspace (@{$self->{subspaces}}){

        for my $ir (0..$n_irreps-1){
            $total[$ir] += $subspace->[$ir];
        }
    }

    return @total;
}

sub orbs_per_subspace_type{
    my ($MAS) = @_;

    if (ref($MAS->[-1]) eq 'ARRAY' ){
        die "Error: Subspace labels required for MAS!\n";
    }

    my %orbitals_per_subspace_type = ('closed', 0, 'active', 0);

    for( my $i = 0; $i < @{$MAS}; $i += 3 ) {
        my $label = lc($MAS->[$i+2]) eq 'active' ? 'active' : 'closed'; 
        my $norbs = 0;
        if (ref($MAS->[$i]) eq 'ARRAY'){
            $norbs = sum0(@{$MAS->[$i]});
        } else {
            $norbs = $MAS->[$i];
        }
        $orbitals_per_subspace_type{$label} += $norbs;
    }   
    return %orbitals_per_subspace_type;
}
# sub distributions
#
# Distribute electrons among orbitals sets using either ORMAS or GAS.
#
# Parameters: $nelec: number of electrons.
#
# Returns: array of arrays of electron distributions

sub distributions{
    my ($self, $nelec) = @_;

    my @dists = ();
    my @subspaces = @{$self->{subspaces}};

    if ($self->{type} == 1){
        @dists = $self->_distributions_ORMAS($nelec);
    } elsif ($self->{type} == 2){
        @dists = $self->_distributions_GAS();
    }

    my $N_dists = scalar @dists;
    my $nspace = scalar @{$self->{N_min}};

    # Make sure no subspace has more electrons than fit in the orbitals.
    for my $i (reverse 0..$N_dists-1){
        for my $j (0..$nspace-1){      
            if (2*sum0(@{$subspaces[$j]}) < $dists[$i]->[$j]) {
                splice(@dists, $i, 1);
                last;
            }
        }
    }

    # If there any further constraints, apply them.
    if (defined($self->{constraints})){
        for my $i (reverse 0..$N_dists-1){       
            if (!$self->{constraints}($dists[$i])) {
                splice(@dists, $i, 1);
            }
        }
    }

    return @dists;
}

# sub _distributions_GAS
#
# Distribute electrons among orbitals sets
#
# Treats the cumulative occupation numbers like a directed acyclic graph
# and does a recursive depth first traversal of it to find all the possible
# distributions.  
#
# As the last set of cumulative occupation numbers must be equal to the number
# of electrons it doesn't require $nelec to be passed.
#
# Returns: array of arrays of electron distributions

sub _distributions_GAS{
    my ($self) = @_;

    my @N_min = @{$self->{N_min}};
    my @N_max = @{$self->{N_max}};

    my $nspace = scalar @N_min;
    my @dists = ();

    sub next_occ{
        my ($dist, $ispace, $nspace, $N_min, $N_max, $dists) = @_;
        if ($ispace == $nspace){
            my $len = scalar @{$dists};
            $dists->[$len] = $dist;
            return;
        }

        my $cum_occ = sum0(@{$dist});
        for my $next_cum_occ (reverse $N_min->[$ispace]..$N_max->[$ispace]){
            my $occ = $next_cum_occ - $cum_occ;

            if ($occ >= 0){
                my @add_occ = ($occ);
                my @new_dist = (@{$dist}, @add_occ);
                next_occ(\@new_dist, $ispace+1, $nspace, $N_min, $N_max, $dists);

            } else {
                return;
            }
        }
    }

    next_occ([], 0, $nspace, \@N_min, \@N_max, \@dists);
    return @dists;
}

# sub _distributions_ORMAS
#
# Distribute electrons among orbitals sets
#
# Uses algorithm in Section III B of Ivanic J. Chem. Phys 119 18 2003)
#
# I have tried to stick closely to the symbols used in the description of the 
# algorithm in the paper. So it should be easy to refer to the paper to see
# what is going on.
#
# Parameters: $nelec: number of electrons.
#
# Returns: array of arrays of electron distributions

sub _distributions_ORMAS{
    my ($self, $nelec) = @_;

    my @N_min = @{$self->{N_min}};
    my @N_max = @{$self->{N_max}};

    my $M_e = $nelec - sum0(@N_min);

    my $X = scalar @N_min; # Get the number of subsets

    my @M_max = pairwise { $a - $b } @N_max, @N_min;

    my @zeros = (0) x $X;
    my @M_ij = (\@zeros);

    my @a = (0..($X - 1));
    for my $i (@a){
        @{$M_ij[0]}[$i] = min($M_max[$i], $M_e - sum0(@{$M_ij[0]}[0..$i]));
    }

    my $found_dist = 1; # True

    while ($found_dist){
        (my $M_ij_row, $found_dist) = _add_next_distribution($X, $M_e, \@M_max, $M_ij[-1]);
        my $len = scalar @M_ij;
        if ($found_dist){
            $M_ij[$len] = $M_ij_row;
        }
    }

    my @dists = ();
    my $N_dists = scalar @M_ij;

    for my $i (0..$N_dists-1){
        my @new_dist = pairwise { $a + $b } @{$M_ij[$i]}, @N_min;
        $dists[$i] = \@new_dist;
    }

    return @dists;
}

sub _add_next_distribution{
    my $X = shift;
    my $M_e = shift;
    my @M_max = @{$_[0]};
    my @M_ij = @{$_[1]};

    my $found_dist = 0;  # False

    for my $i (reverse(0..$X-1)){
        if ($M_ij[$i] > 0){
            for my $k ($i+1..$X-1){
                if ($M_ij[$k] < $M_max[$k]){
                    $M_ij[$i] -= 1;
                    my $M_r = $M_e - sum0(@M_ij[0..$k-1]);

                    for my $p ($k..$X-1){
                        $M_ij[$p] = min($M_max[$p], $M_r - sum0(@M_ij[$k..$p-1]));
                    }
                    $found_dist = 1;
                    return (\@M_ij, $found_dist);
                }
            }
        }
    }

    return $found_dist;
}

# sub set_orbs_per_irrep_per_subspace_automatically
#
# Sets orbitals per irrep per subspace from ordered list of orbitals.
#
# Given the number of orbitals per subspace and an ordered list of orbitals
# figure out the number of orbitals per irrep per subspace. The input array
# describing the multiple active spaces is modified so that the scalar number 
# of orbitals in a subspace is replacedwith an array denoting the number of
# orbitals per irrep in that subspace.
#
# Parameters: 
#    $r_MAS: The multiple active spaces in the format accepted by MultiSpace.
#    $r_sorted_orb: List of sorted orbitals in the format produced by UKRmol-scripts.
#
sub set_orbs_per_irrep_per_subspace_automatically {
    my ($r_MAS, $r_sorted_orb) = @_;
    
    my $r_MAS_new = dclone($r_MAS);
    if (ref($r_MAS->[0]) ne 'ARRAY'){
        if (!defined($r_sorted_orb)){
            die "Ordered list of orbitals required if only total orbitals per active space is given!";
        }

        my $step = 3;
        if (ref($r_MAS->[-1]) eq 'ARRAY' ){  # We don't have labels
            $step = 2; 
        }
        my $first_orb = 0;

        for(my $i = 0; $i < @{$r_MAS_new}; $i += $step) {
            my @space = (0) x 8;
            my $last_orb = $first_orb + $r_MAS_new->[$i] - 1;
            for (my $j = $first_orb; $j <= $last_orb; $j++) { 
                $r_sorted_orb->[$j] =~ m/(\d+)\.(\d+)/;
                $space[$1-1]++;
            }
            $first_orb = $last_orb + 1;
            $r_MAS_new->[$i] = \@space;
        }
    }

    return $r_MAS_new;
}

# ----------------------- COUNT CSF -------------------------------------------
#
# Here we have routines for determining the number of CSF that a particular
# MAS will produce. These work by constructing the Shavitt graph then using
# a fast iterative approach to count the number of CSF it produces. It requires 
# no external combinatorics libraries unlike the approach in MultiSpace::Count 
# which is now deprecated, and has no practical limitation on the size of
# active spaces that can be used.
#
#------------------------------------------------------------------------------

# sub make_distinct_row_table
#
# Create the Distinct Row Table (DRT)
#
# The DRT is an adjacency list for the Shavitt graph representing the configuration
# space produced by a particular active space. A Shavitt graph is a directed acyclic graph
# with a single head corresponding to all oribitals placed (first row/node = 1), 
# and a tail corresponding to no orbitals placed (last row/node). Each CSF is then a 
# different walk for head to tail (or from tail to head). There are four different types
# of chains/edges/arcs between rows/nodes.
#
# Going from head to tail (downwards chaining links)
#
# d0: remove one empty orbital: (a, b, c-1)
# d1: remove orbital so as to reduce spin by 1/2: (a, b-1, c)
# d2: remove orbital so as increase spin by 1/2 (reduce paired spins and empty orbitals 
#     by one each): (a-1, b+1, c-1).
# d3: remove one doubly occupied orbital: (a-1, b, c)
#
# If we want to go from tail to head (upward chaining links) we need the
# complimentary edges in the reversed graph.
#
# u0: add one empty orbital
# u1: add orbital so as to increase spin by 1/2
# u2: add orbital so as decrease spin by 1/2 (increase paired spins and empty orbitals 
#     by one each)
# u3: add one doubly occupied orbital
#
# Each row in the DRT is uniquely specified by the triplet (a,b,c), extra
# columns denote the level (orbital index), the irrep of the orbital, and
# a place holder column for the subspace index of the orbital for use in the 
# MAS approach.
#
# Parameters: $a: total number of paired spins.
#             $b: total number of unpaired spins.
#             $c: total number of empty orbitals.
#             $ordered_orbs: ordered list of orbitals with elements "$sym.$index_in_sym"
#                            Note: Sym index starts from 1 here!! This is the convention
#                            found in molpro molden files.
#
# Returns: hash containing the distinct row table, key = row number, 
#          value = [level, orb_irrep, space_index, a, b, c, d0, d1, d2, d3].

sub dimension{
    my ($self, $nelectrons, $S) = @_;

    my %nocsf = count_csfs($self, $nelectrons, $S);
    return %nocsf;
}

sub make_distinct_row_table {
    my ($a, $b, $c, $ordered_orbs) = @_;

    my $level = $a + $b + $c;  # The number of orbitals placed in total
    
    # We only need the symmetry of each orb so extract.
    my $nordered_orbs = scalar @{$ordered_orbs};
    if ($level > $nordered_orbs) {
        die "Error: $level ordered orbitals required but only $nordered_orbs supplied";
    }
    my @orbs;
    for my $i (0..$level-1){
        $ordered_orbs->[$i] =~ m/(\d+)\.(\d+)/;
        push(@orbs, $1 - 1); # Sym index starts from 1!!
    }

    my %drt;
    my %row_created;
    $row_created{"($a,$b,$c)"} = 1;

    my $orb_irrep = $orbs[$level-1];
    $drt{1} = [$level, $orb_irrep, 0, $a, $b, $c, 0,0,0,0];

    my $curr_row = 1;
    my $next_row = 2;

    my ($aa, $bb, $cc, $next_orb_irrep);

    while ($level) {

        $level = $drt{$curr_row}->[0];
        $next_orb_irrep = $orbs[$level-2];

        $aa = $drt{$curr_row}->[3]; $bb = $drt{$curr_row}->[4]; $cc = $drt{$curr_row}->[5];       

        # d0: remove one empty orbital
        if ($cc) {
            $next_row = add_row_to_drt($level-1, $next_orb_irrep, $aa, $bb, $cc-1, \%row_created, $curr_row, $next_row, 0, \%drt);
        }
        # d1: reduce spin by 1/2
        if ($bb) {
            $next_row = add_row_to_drt($level-1, $next_orb_irrep, $aa, $bb-1, $cc, \%row_created, $curr_row, $next_row, 1, \%drt);
        }
        # d2: remove one doubly occupied and one empty orbital and increase spin by 1/2
        if ($aa && $cc) {
            $next_row = add_row_to_drt($level-1, $next_orb_irrep, $aa-1, $bb+1, $cc-1, \%row_created, $curr_row, $next_row, 2, \%drt);
        }
        # d3: remove one doubly occupied orbital
        if ($aa) {
            $next_row = add_row_to_drt($level-1, $next_orb_irrep, $aa-1, $bb, $cc, \%row_created, $curr_row, $next_row, 3, \%drt);
        }
        $curr_row += 1;
    }

    add_upward_chains(\%drt);
    
    return %drt;
}

sub add_row_to_drt { 
    my ($next_level, $next_orb_irrep, $a, $b, $c, $row_created, $curr_row, $next_row, $d, $drt) = @_;

    if (!exists($row_created->{"($a,$b,$c)"})) {
        $drt->{$next_row} = [$next_level, $next_orb_irrep, 0, $a, $b, $c, 0,0,0,0];
        $row_created->{"($a,$b,$c)"} = $next_row;
        $drt->{$curr_row}[6+$d] = $next_row;
        $next_row += 1;
    } else {
        $drt->{$curr_row}[6+$d] = $row_created->{"($a,$b,$c)"};
    }
    
    return $next_row;
}

sub add_upward_chains {
    my ($drt) = @_;

    my $nrows = keys %{$drt};

    my $level; my $jrow; my @upward_chains; my @downward_chains; my $i;

    for my $irow (reverse 2..$nrows){
        $level = $drt->{$irow}[0];
        $jrow = $irow - 1;
        @upward_chains = (0,0,0,0);

        while ($jrow && ($drt->{$jrow}[0] <= $level + 1)) {
            @downward_chains = @{$drt->{$jrow}}[6..9];
            if (grep { $irow == $_ } @downward_chains) {
                $i = first_index { $_ == $irow } @downward_chains;
                $upward_chains[$i] = $jrow;
            }
            $jrow -= 1
        }
        push(@{$drt->{$irow}}, @upward_chains);
    }
    @upward_chains = (0,0,0,0);
    push(@{$drt->{1}}, @upward_chains);
}

# sub make_distinct_row_table_gas
#
# Create the Distinct Row Table (DRT) that corresponds to GAS
#
# The GAS approach can be simply represented by deleting the relevant rows/nodes
# in the DRT. Such an approach does not work for ORMAS, for the ORMAS case
# no rows are deleted, only the space index column is filled out.
#
# Parameters: $mas: MAS (MultiSpace)
#             $nelectrons: Number of electrons (int).
#             $S: Spin multiplicity (int).
#
# Returns: hash containing the distinct row table

sub make_distinct_row_table_gas {
    my ($mas, $nelectrons, $S) = @_;

    my $total_orb = 0;
    my @last_orb;
    my @orb_space_index;

    foreach my $subspace (@{$mas->{subspaces}}){
        $total_orb += sum0(@{$subspace});
        push(@last_orb, $total_orb);
    }

    my $b = $S - 1;
    my $a = int(($nelectrons - $b )/2);
    my $c = $total_orb - $a - $b;

    my %drt = make_distinct_row_table($a, $b, $c, $mas->{ordered_orbitals});
    
    my $nrows = keys %drt;

    # Add space index to the drt
    my $cur_orb;
    my $cur_space = 0;
    for my $irow (1..$nrows){
        $cur_orb = $drt{$irow}->[0];
        $cur_space = 0;
        
        foreach my $elm (@last_orb){
            if ($cur_orb > $elm){$cur_space ++;}
        }
        $drt{$irow}->[2] = $cur_space;
    }

    if ($mas->{type} == 1){
        return %drt;
    }

    # Flag rows that don't satisfy min max occupancy for removal
    my @removed_rows;
    my $orbs_left;
    my $max_el_placable;
    my $nel;
    for my $irow (1..$nrows){
        $cur_orb = $drt{irow}->[0];
        $cur_space = $drt{irow}->[2];

        if ($cur_orb == $last_orb[$cur_space]){
            $nel = 2*$drt{$irow}->[3] + $drt{$irow}->[4];
            if ($nel < $mas->{min_max_electrons}[$cur_space][0] || $nel > $mas->{min_max_electrons}[$cur_space][1]){
                push(@removed_rows, $irow);
            }
        } elsif ($cur_orb < $last_orb[$cur_space]){
            $orbs_left = $last_orb[$cur_space] - $cur_orb;
            $max_el_placable = 2*$orbs_left;
            if ($nel < $mas->{min_max_electrons}[$cur_space][0] - $max_el_placable){
                push(@removed_rows, $irow);
            }
        }
    }
    # Delete rows
    my $ncols = scalar @{$drt{1}};
    foreach my $irow (@removed_rows){
        $drt{irow}->[$ncols-8..$ncols-1] = [0,0,0,0,0,0,0,0];
    }

    # Delete all links to deleted rows
    foreach my $irow (keys %drt){
        for my $i ($ncols-8..$ncols-1){
            if (grep { $drt{$irow}->[$i] == $_ } @removed_rows) {
                $drt{$irow}->[$i] = 0;
            }
        }
    }
    return %drt;
}

# sub count_csfs
#
# Calculate the number of CSF generated by a MAS. The algorithm works by
# first constructing the Shavit graph then going from tail to head and 
# iteratively calculating the number of walks of each symmetry and occupation
# that reach lead to a node from the number of walks that lead to the 
# previous nodes linked to it. In the ORMAS case occupation restrictions are
# applied when a new active space is entered.
#
# Parameters: $mas: MAS (MultiSpace)
#             $nelectrons: Number of electrons (int).
#             $S: Spin multiplicity (int).
#
# Returns: hash containing the number of csf for each symmetry.

sub count_csfs {
    my ($mas, $nelectrons, $S) = @_;

    my %drt = make_distinct_row_table_gas($mas, $nelectrons, $S);

    my $d0 = 6; my $d3 = 9;

    my $nrows = keys %drt;
    my %n_lower_walks;
    $n_lower_walks{$nrows} = {0 => {0 => 1}};

    # For each node, calculate the number of lower walks per sym per occupancy 
    # that reach it.
    my ($cur_space, $occ_incr, $orb_irrep, $jrow, $walk_irrep,  $prev_node_space);
    my (%nw, %val);

    for my $irow (reverse 1..$nrows-1){

        $cur_space = $drt{$irow}->[2];
        %nw = ();
        for my $arc ($d0..$d3){
            
            if ($arc == $d0 || $arc == $d3){  # No contributions total sym
                $occ_incr = 0;
                $orb_irrep = 0;
                if ($arc == $d3) { $occ_incr = 2; }
            } else {
                $occ_incr = 1;
                $orb_irrep = $drt{$irow}->[1];
            }
            $jrow = $drt{$irow}->[$arc];

            if ($jrow != 0) {
                foreach my $prev_irrep (sort keys %{$n_lower_walks{$jrow}}) {

                    %val = %{$n_lower_walks{$jrow}{$prev_irrep}};
                    $walk_irrep = $group_table[$orb_irrep]->[$prev_irrep];
                    $prev_node_space = $drt{$jrow}->[2];
                    if ($prev_node_space != $cur_space) {
                        while (my($occ, $no_walks) = each %val) {
                            if ($mas->{type} == 1) {
                                # Perform ORMAS occupancy check here i.e. min <= occ <= max
                                # for walks to take on from previous space.
                                if ($mas->{N_min}[$prev_node_space] <= $occ && $occ <= $mas->{N_max}[$prev_node_space]) {
                                    $nw{$walk_irrep}{$occ_incr} += $no_walks;
                                }
                            } else {
                                $nw{$walk_irrep}{$occ_incr} += $no_walks;
                            }
                        }                        
                    } else {
                        while (my ($occ, $no_walks) = each %val) {
                            $nw{$walk_irrep}{$occ+$occ_incr} += $no_walks;
                        }
                    }
                }
            }
        }         
        $n_lower_walks{$irow} = dclone(\%nw);
    }

    my %nocsf;
    while (my($sym, $v) = each %{$n_lower_walks{1}}) {
        while (my($occ, $ncsf) = each %{$v}) {
            if ($mas->{N_min}[-1] <= $occ && $occ <= $mas->{N_max}[-1]) {
                $nocsf{$sym} += $ncsf;
            }
        }
    }
    return %nocsf;
}

# ----------------------- CONGEN ----------------------------------------------
#
# Here we have routines that are specific to translating from the internal 
# MAS representation of the space to the congen specific format.
#
#------------------------------------------------------------------------------

# sub _congen_subspaces
#
# Constructs the congen representation of the subspaces.

sub _congen_subspaces{
    my ($self) = @_;

    my @subspaces = @{$self->{subspaces}};

    my $n_subspaces = scalar @subspaces; # Get the number of subsets
    my $n_irreps = scalar @{$irred_repr{$self->{'symmetry'}}};
    # To account for case where subspace arrays are padded at the end with zeros instead 
    # of being the same size as $n_irreps.
    my $dim_subspace = scalar @{$subspaces[0]};

    # We will need to figure out the start and end indexes of the orbitals 
    # in each set to construct the subsets in congen format.
    my @pqn_ini = (1) x $dim_subspace;
    my @pqn_fin = (0) x $dim_subspace;

    # These arrays describe the subspaces for all electron distributions over
    # the subsets, however for a specific distribution we don't include the 
    # subspace in the congen input if it has zero electron occupancy. 
    my @all_nshlp = ();
    my @all_pqn = ();
    my @all_mshl = ();

    for my $iset (0..$n_subspaces-1){
        my @pqn_set = ();
        my @mshl_set = ();
        my $count_triplets = 0;

        @pqn_fin = pairwise { $a + $b } @pqn_fin, @{$subspaces[$iset]};

        for my $irrep (0..$n_irreps-1){
            if ($pqn_fin[$irrep] >= $pqn_ini[$irrep]){
                push(@pqn_set, [0, $pqn_ini[$irrep], $pqn_fin[$irrep]]);
                push(@mshl_set, $irrep);
                $count_triplets += 1;

            }
        }
        push(@all_pqn, \@pqn_set);
        push(@all_mshl, \@mshl_set);
        push(@all_nshlp, $count_triplets);

        @pqn_ini = pairwise { $a + $b } @pqn_ini, @{$subspaces[$iset]};

    }

    my @congen_subspaces = (\@all_pqn, \@all_mshl, \@all_nshlp );

    return @congen_subspaces;
}

# sub congen_target
#
# Create the relevant &wfngrp namelist variables for each electron distribution
# in the target space. A single electron distribution corresponds to a single 
# wfngrp.
#
# Parameters: $nelec: number of electrons.
#
# Returns: array of hashes containing the relevant namelist variables for each wfngrp.

sub congen_target{
    my ($self, $nelec) = @_;

    my @subspaces = @{$self->{subspaces}};
    my $n_subspaces = scalar @subspaces; # Get the number of subsets

    # Now generate all distributions and construct the wfngrps corresponding
    # to each one.
    my @dists = $self->distributions($nelec);
    my $n_dists = scalar @dists;

    my @congen_subspaces = $self->_congen_subspaces();   
    my @all_pqn = @{$congen_subspaces[0]};
    my @all_mshl = @{$congen_subspaces[1]};
    my @all_nshlp = @{$congen_subspaces[2]};

    my @wfngrps = ();

    for my $idist (0..$n_dists-1){
        my %wfngrp = (QNTAR => [-1,0,0], NDPROD => 0, NELECP => [], NSHLP => [], PQN => [], MSHL => []);
        my $count_non_zero_sets = 0;
        for my $iset (0..$n_subspaces-1){
            # Remember we don't include the subset if the occupancy is zero.
            if ($dists[$idist][$iset] > 0){
                push(@{$wfngrp{'NELECP'}}, $dists[$idist][$iset]);
                push(@{$wfngrp{'NSHLP'}}, $all_nshlp[$iset]);
                for my $ipqn (0..$all_nshlp[$iset]-1){
                    push(@{$wfngrp{'PQN'}}, @{$all_pqn[$iset][$ipqn]});
                }
                push(@{$wfngrp{'MSHL'}}, @{$all_mshl[$iset]});
                $count_non_zero_sets += 1;
            }
        }
        my $id = $idist + 1;
        if ($self->{type} == 1){
            $wfngrp{'GNAME'} = "ORMAS distribution $id/$n_dists";
        } elsif ($self->{type} == 2){
            $wfngrp{'GNAME'} = "GAS distribution $id/$n_dists";
        }
        $wfngrp{'NDPROD'} = $count_non_zero_sets;
        push(@wfngrps, \%wfngrp);
    }

    return @wfngrps;
}

# sub _congen_target_x_continuum
#
# Create the target x continuum wfngrps for one target state symmetry
#
# Parameters: $nelec: number of electrons.
#             $nob0: target orbitals per irrep excluding virtuals
#             $qntot: scattering symmetry
#             $qntar: target state symmetry
#
# Returns: array of hashes containing the relevant namelist variables for each wfngrp.

sub _congen_target_x_continuum{
    my ($self, $nelec, $nob0, $qntot, $qntar) = @_;

    my @wfngrps = $self->congen_target($nelec);
    my $n_wfngrps = scalar @wfngrps;

    my $sym_cont = $group_table[$qntot->[1]][$qntar->[1]];

    my %spin_label = reverse %spin_multiplicity;

    foreach my $wfngrp (@wfngrps){
        $wfngrp->{'QNTAR'} = [$qntar->[0], $qntar->[1], 0];
        push(@{$wfngrp->{'NELECP'}}, 1);
        push(@{$wfngrp->{'NSHLP'}}, 1);
        push(@{$wfngrp->{'PQN'}}, (0, $nob0->[$sym_cont] + 1, $nob0->[$sym_cont] + 2));
        push(@{$wfngrp->{'MSHL'}}, $sym_cont);
        $wfngrp->{'NDPROD'} += 1;
        my $spin_targ = $spin_label{$qntar->[0]};
        my $sym_targ = $irred_repr{$self->{symmetry}}[$qntar->[1]];
        $wfngrp->{'GNAME'} = $spin_targ . " " . $sym_targ . " (" . $wfngrp->{'GNAME'} . ") x continuum^1";
    }

    return @wfngrps;
}

# sub congen_scattering
#
# Create &wfngrps for one scattering symmetry (continuum and L2) 
#
# Parameters: $nelec: number of electrons.
#             $nob0: target orbitals per irrep excluding virtuals
#             $qntot: scattering symmetry
#             $all_qntar: all target state symmetries
#             $l2_space: MultiSpace object describing the L2 space (optional)
#
# Returns: array of hashes containing the relevant namelist variables for each wfngrp.

sub congen_scattering{
    my ($self, $nelec, $nob0, $qntot, $all_qntar, $l2_space) = @_;

    my @wfngrps = ();
    foreach my $qntar (@$all_qntar){
        my @wfngrps_qntar = $self->_congen_target_x_continuum($nelec, $nob0, $qntot, $qntar);
        push(@wfngrps, @wfngrps_qntar);
    } 

    # Now set up the l2 space if it is not supplied.
    # The default is to allow the continuum electron into target space.

    my @l2_wfngrps = ();

    if (!defined $l2_space){

        my @l2_N_max = ();
        my @subspaces = @{$self->{subspaces}};
        my $n_subspaces = scalar @subspaces; # Get the number of subsets
        
        if ($self->{type} == 1){  # ORMAS approach
            for my $i (0..$n_subspaces-1){
                my $n_holes = 2 * sum0(@{$subspaces[$i]});
                if ($self->{'N_max'}[$i] < $n_holes){
                    push(@l2_N_max, $self->{'N_max'}[$i] + 1);
                } else {
                    push(@l2_N_max, $self->{'N_max'}[$i]);
                }
            }

            my $l2_space = dclone($self);
            $l2_space->{'N_max'} = \@l2_N_max;
            @l2_wfngrps = $l2_space->congen_target($nelec + 1);

        } elsif ($self->{type} == 2){  # GAS approach
            my $n_holes = 0;
            for my $i (0..$n_subspaces-1){
                $n_holes += 2 * sum0(@{$subspaces[$i]});
                if ($self->{'N_max'}[$i] < $n_holes){
                    push(@l2_N_max, $self->{'N_max'}[$i] + 1);
                } else {
                    push(@l2_N_max, $self->{'N_max'}[$i]);
                }
            }

            my $l2_space = dclone($self);
            $l2_space->{'N_max'} = \@l2_N_max;
            $l2_space->{'N_min'}[$n_subspaces-1] = $l2_space->{'N_max'}[$n_subspaces-1];
            @l2_wfngrps = $l2_space->congen_target($nelec + 1);
        } 
        
    } else {
        @l2_wfngrps = $l2_space->congen_target($nelec + 1);
    }
    foreach my $wfngrp (@l2_wfngrps){
        $wfngrp->{'GNAME'} = "L^2: " . $wfngrp->{'GNAME'};
    }
    
    push(@wfngrps, @l2_wfngrps);

    return @wfngrps;
}

# ------------- QUANTUM CHEMISTRY CODE INTERFACES -----------------------
#
# Routines for intefacing with quantum chemistry codes
#
#------------------------------------------------------------------------

# sub map_to_qchem_sym_order
#
# Maps from the irrep order used in MultSpace (the same as Molpro) to the irrep 
# order used in the selected quantum chemistry code. If integer is input return
# equivalent qchem irrep index. If array is input return array reordered to 
# qchem code irrep order (where the array index is the irrep index). 
# 
sub map_to_qchem_irrep_order {
    my ($irreps, $point_group, $qchem) = @_;

    my %qchem_irred_repr;
    my $qchem_irreps;

    if ($qchem eq "molcas"){
        %qchem_irred_repr = (
            'D2h', [ "Ag", "B3u", "B2u", "B1g", "B1u", "B2g", "B3g", "Au" ],
            'C2v', [ "A1", "B1", "B2", "A2" ],
            'C2h', [ "Ag", "Bu", "Au", "Bg" ],
            'D2',  [ "A", "B3", "B2", "B1" ],
            'C2',  [ "A", "B" ],
            'Cs',  [ "Ap", "App" ],
            'Ci',  [ "Ag", "Au" ],
            'C1',  [ "A" ],
        );
    } else { die "Error: $qchem not yet implemented in MultiSpace!"}

    my $nir = scalar @{$irred_repr{$point_group}};

    if (ref($irreps) eq 'ARRAY' ){
        my @arr = (0) x scalar @{$irreps};
        for my $idx_irrep (0..$nir-1){
            my $irrep_label = $irred_repr{$point_group}->[$idx_irrep];
            my $idx_qc_irrep = first_index { $_ eq  $irrep_label} @{$qchem_irred_repr{$point_group}};
            $arr[$idx_qc_irrep] = $irreps->[$idx_irrep];
        }
        $qchem_irreps = \@arr;
    } else {
        my $irrep = $irred_repr{$point_group}->[$irreps];
        $qchem_irreps = first_index { $_ eq  $irrep} @{$qchem_irred_repr{$point_group}};
    }

    return $qchem_irreps;
}

# ----------------------- MOLCAS ----------------------------------------------
#
# Here we have routines that are specific to translating from the internal 
# GAS representation of the space to the Molcas specific format.
#
#------------------------------------------------------------------------------

#
# Assumes one frozen and one inactive subspace which must come before any 
# active subspaces. Think about what to do with deleted orbitals, perhaps
# it should be a seperate optional entry.
#
sub molcas_gasscf_input{
    my ($self) = @_;

    my %gasscf = (
        'NACTEL', [0,0,0], 
        'FROZEN', [0,0,0,0,0,0,0,0],
        'INACTIVE', [0,0,0,0,0,0,0,0],
        'GASSCF', [],
    );

    my $n_subspaces = scalar @{$self->{subspaces}};
    my $n_active_subspaces = $n_subspaces;
    my $index_first_active_space = 0;
    # map_to_qchem_irrep_order(\@C2h_multispace_order, $self->{'symmetry'}, "molcas");
    for my $i (0..$n_subspaces-1){
        if ($self->{subspace_labels}[$i] eq "frozen"){
            $n_active_subspaces -= 1;
            $gasscf{FROZEN} = map_to_qchem_irrep_order($self->{subspaces}[$i], $self->{'symmetry'}, "molcas");
            $index_first_active_space = $i + 1;           
        }
        if ($self->{subspace_labels}[$i]  =~ /(closed|inactive)/){
            $n_active_subspaces -= 1;
            $gasscf{INACTIVE} = map_to_qchem_irrep_order($self->{subspaces}[$i], $self->{'symmetry'}, "molcas");
            $index_first_active_space = $i + 1;
        }     
    }

    my $ninactel = 0;
    if ($index_first_active_space > 0){
        $ninactel = $self->{N_min}[$index_first_active_space-1];
    }
    $gasscf{NACTEL}->[0] = $self->{N_min}[-1] - $ninactel;

    my @GAS = ([$n_active_subspaces]);

    for my $i ($index_first_active_space..$n_subspaces-1){
        push(@GAS, map_to_qchem_irrep_order($self->{subspaces}[$i], $self->{'symmetry'}, "molcas"));
        push(@GAS, [$self->{N_min}[$i] - $ninactel, $self->{N_max}[$i] - $ninactel]);
    }

    $gasscf{GASSCF} = \@GAS;

    return %gasscf;
}

# ----------------------- MOLPRO ----------------------------------------------
#
# Here we have routines that are specific to translating from the internal 
# ORMAS representation of the space to the Molpro specific format.
#
#------------------------------------------------------------------------------

#
# There should be at most one frozen and one close subspace which must come 
# before any active subspaces. If there is one active space then it is assumed
# to be a standard CAS model. If there are more than one it is an ORMAS
# model and the molpro global RESTRICT keyword is used to contruct the space.
# This implicitly means that we switch to using the Molpro CSF basis instead
# of the determinant basis. In consequence, state averaging over different spin
# states is not allowed. 
#
sub molpro_ormas_input{
    my ($self) = @_;

    my %multi = (
        'FROZEN', [0,0,0,0,0,0,0,0],
        'CLOSED', [0,0,0,0,0,0,0,0],
        'OCC', [0,0,0,0,0,0,0,0],
        'ORMAS', "",
    );

    my $n_subspaces = scalar @{$self->{subspaces}};
    my $n_active_subspaces = $n_subspaces;
    my $index_first_active_space = 0;
    my @cuml_space = (0,0,0,0,0,0,0,0);

    for my $i (0..$n_subspaces-1){
        if ($self->{subspace_labels}[$i] eq "frozen"){
            $n_active_subspaces -= 1;
            for my $j (0..7){
                $cuml_space[$j] +=  $self->{subspaces}[$i][$j];
                $multi{FROZEN}->[$j] = $cuml_space[$j];
            }
            $index_first_active_space = $i + 1;           
        }
        if ($self->{subspace_labels}[$i] =~ /(closed|inactive)/){
            $n_active_subspaces -= 1;
            for my $j (0..7){
                $cuml_space[$j] +=  $self->{subspaces}[$i][$j];
                $multi{CLOSED}->[$j] = $cuml_space[$j];
            }
            $index_first_active_space = $i + 1;
        }     
    }

    if ($n_active_subspaces > 1){
        
        my $restrict_cards = "config;\n";
        my @molpro_subspaces = ("") x $n_subspaces;

        # Setup the molpro subspaces
        for my $i ($index_first_active_space..$n_subspaces-1){
            $restrict_cards .= "restrict, $self->{N_min}[$i], $self->{N_max}[$i]";
            for my $j (0..7){
                if ($self->{subspaces}[$i][$j]){
                    for my $k (1..$self->{subspaces}[$i][$j]){
                        my $iorb = $cuml_space[$j] + $k;
                        my $isym = $j+1;
                        $molpro_subspaces[$i] .= ", $iorb.$isym";
                    }
                }
                $cuml_space[$j] +=  $self->{subspaces}[$i][$j];
            }
            $restrict_cards .= $molpro_subspaces[$i].";\n";
        }

        # Additional constraints
        # Note: Assumes that constraint are of the molpro style i.e. only specifying
        # that certain occupancy numbers are not allowed in a subspace.

        if (defined($self->{constraints})){
            for my $i (0..$n_subspaces-1){
                my @dists = (-1) x $n_subspaces;
                for my $occ ($self->{N_min}[$i]..$self->{N_max}[$i]){
                    $dists[$i] = $occ;
                    if (!$self->{constraints}(\@dists)) {
                        $restrict_cards .= "restrict, -$occ, 0".$molpro_subspaces[$i].";\n";
                    }                    
                }
            }
        }        

        for my $j (0..7){$multi{OCC}->[$j] = $cuml_space[$j];}
        $multi{ORMAS} = $restrict_cards;

    } elsif ($n_active_subspaces == 1) {
        for my $j (0..7){
            $cuml_space[$j] +=  $self->{subspaces}[$index_first_active_space][$j];
            $multi{OCC}->[$j] = $cuml_space[$j];
        }
    } else {

    }

    return %multi;
}

# ----------------------- MOLDEN ----------------------------------------------
#
# Here we have routines that are for reading orbitals and sorting from a 
# molden file, each quantum chemistry code has a slightly different form of 
# molden output currently the following codes are supported: Molpro and Molcas
#
#------------------------------------------------------------------------------
sub read_orbitals_from_molden{
    my ($qchem_code, $file, $point_group) = @_;

    my $nir = scalar @{$irred_repr{$point_group}};

    open my $in,  '<',   $file or die "Could not open $file: $!";

    my $section = "";
    my $head = "";

    my $orb_label;

    my @orbitals;
    my $orb_str;
    my $orb_index = -1;

    my $orbital = {};
    my @molden_order_orbs;

    while( my $line = <$in>)  {

        if ($section eq 'MO'){

            if ($line =~ /(Sym=|Ene=|Spin=|Occup=)/){
                if ($line =~ /Sym=/){
                    if ($orb_index > -1){
                        push(@orbitals, $orbital);
                    }
                    $orb_index++;
                    $orbital = {}; 
                    $orbital->{'OrbitalStr'} = $line;
                    
                    chomp($line);
                    my @tokens = split ' ', $line;
                    my $ir;
                    if ($qchem_code eq 'molcas'){
                        my ($index, $letter, $sym) = split /([a-zA-Z])/, $tokens[1], 2;
                        $sym = uc($letter) . $sym if $letter;
                        $sym =~ s/'/p/g;
                        $sym =~ s/"/pp/g;
                        $ir = first_index { $_ eq $sym } @{$irred_repr{$point_group}};
                        $ir++;
                        $orbital->{"Idx_in_sym="} = $index;                        
                        $orbital->{"$tokens[0]"} = $ir;

                    } elsif ($qchem_code eq 'molpro'){
                        my ($index, $point, $ir) = split /(\.)/, $tokens[1], 2;
                        $orbital->{"Idx_in_sym="} = $index;
                        $orbital->{"$tokens[0]"} = $ir;
                    }
                    next;
                } 
                else { 
                    $orbital->{'OrbitalStr'} .= $line;
                    chomp($line);
                    my @tokens = split ' ', $line;
                    $orbital->{"$tokens[0]"}=$tokens[1];
                }
            }
            else {
                $orbital->{'OrbitalStr'} .= $line;
            }

        } 
        elsif ($line =~ /\[(\w+)\]/ ){
            $section = $1;
            $head .= $line;
        }
        else {
            $head .= $line;
        }

    }
    push(@orbitals, $orbital);

    close $in;

    return @orbitals;
}
# sub sort_molden_orbitals
#
# Sorts array of molden orbitals such that orbitals in the nth subpace precede
# orbitals in the (n+1)th subspace. Within a subspace orbitals are sorted by
# occupation then by energy with the condition that the order of orbitals
# within a symmetry remain unchanged. The orbitals in Molpro molden files 
# should already have this ordering, but in Molcas molden files orbitals are
# ordered by symmetry first. 
# 
sub sort_molden_orbitals{
    my (%args) = @_;
    my $orbitals = $args{'orbitals'};
    my $method = $args{'method'};
    my $subspaces = $args{'subspaces'};

    my @sorted_orbitals;

    my %orbital_hash = (
        1 => [], 2 => [], 3 => [], 4 => [], 5 => [], 6 => [], 7 => [], 8 => [],
    );
    foreach my $orb (@{$orbitals}){
        push(@{$orbital_hash{$orb->{'Sym='}}}, $orb);
    }

#   Sort by occupancy then energy within a subspace
#   while preserving order within symmetry.
    my $nir = scalar @{$subspaces->[0]};
    foreach my $subspace (@{$subspaces}){
        my $norbs = sum0(@$subspace);
        my @ss = @$subspace;
        while ($norbs > 0) {
            my $greatest_occ = -1;
            my $lowest_en = 1000000000;
            my $isym_curr = -1;            
            for my $isym (0..$nir-1){
                if ($ss[$isym] > 0){
                    if ($orbital_hash{$isym+1}->[0]->{'Occup='} > $greatest_occ){
                        $greatest_occ = $orbital_hash{$isym+1}->[0]->{'Occup='};
                        $lowest_en = $orbital_hash{$isym+1}->[0]->{'Ene='};
                        $isym_curr = $isym;
                    } elsif ($orbital_hash{$isym+1}->[0]->{'Occup='} == $greatest_occ){
                        if ($orbital_hash{$isym+1}->[0]->{'Ene='} < $lowest_en){
                            $lowest_en = $orbital_hash{$isym+1}->[0]->{'Ene='};
                            $isym_curr = $isym;
                        }
                    }
                }
            }
            my $orb = shift @{$orbital_hash{$isym_curr+1}};
            push(@sorted_orbitals, $orb);
            $ss[$isym_curr] -= 1;
            $norbs -= 1;         
        }
    }

    # Now we sort the virtual orbitals by energy, again preserving order within a
    # symmetry.
    my @syms_with_orbs = (1) x $nir;
    while (sum0(@syms_with_orbs) > 0){
        my $lowest_en = 100000000000;
        my $isym_curr = -2;
        for my $isym (0..$nir-1){
            if (scalar @{$orbital_hash{$isym+1}} > 0){
                if ($orbital_hash{$isym+1}->[0]->{'Ene='} < $lowest_en){
                    $lowest_en = $orbital_hash{$isym+1}->[0]->{'Ene='};
                    $isym_curr = $isym;
                }
            } else {
                $syms_with_orbs[$isym] = 0;
            }
        }
        if ($isym_curr >= 0){
            my $orb = shift @{$orbital_hash{$isym_curr+1}};
            push(@sorted_orbitals, $orb);
        }
    }

    return @sorted_orbitals;
}
1;